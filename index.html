<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Карточный Бегун</title>
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            touch-action: none;
        }
        
        #game-container {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
        
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .stats-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            pointer-events: auto;
            min-width: 250px;
        }
        
        .stats-panel h3 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 16px;
        }
        
        .stat-value {
            color: #00ffea;
            font-weight: bold;
        }
        
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffaa00;
            pointer-events: auto;
            max-width: 300px;
        }
        
        .controls-info h4 {
            color: #ffaa00;
            margin-bottom: 8px;
        }
        
        .controls-info p {
            font-size: 14px;
            margin: 3px 0;
        }
        
        .cards-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff5555;
            pointer-events: auto;
            min-width: 180px;
        }
        
        .card-info {
            margin: 8px 0;
            padding: 8px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
        }
        
        .card-positive {
            background: rgba(0, 100, 255, 0.3);
            border: 1px solid #0088ff;
        }
        
        .card-negative {
            background: rgba(255, 50, 50, 0.3);
            border: 1px solid #ff5555;
        }
        
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
        }
        
        .game-over h1 {
            color: #ff5555;
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        .game-over p {
            font-size: 24px;
            margin: 10px 0;
            color: #00ffea;
        }
        
        .restart-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #ff5555, #ffaa00);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.3s;
        }
        
        .restart-btn:hover {
            transform: scale(1.05);
        }
        
        .ability-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 15px;
            border: 3px solid #00ff88;
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
            z-index: 50;
            text-align: center;
            display: none;
            min-width: 300px;
        }
        
        .mobile-controls {
            position: fixed;
            bottom: 100px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            display: none;
            pointer-events: auto;
        }
        
        .mobile-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            color: white;
            border: 2px solid white;
            user-select: none;
        }
        
        .joystick-area {
            position: fixed;
            bottom: 100px;
            left: 50px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: none;
            pointer-events: auto;
        }
        
        .joystick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 30px;
            left: 30px;
        }
        
        @media (max-width: 768px) {
            .stats-panel, .cards-panel {
                padding: 10px;
                min-width: 150px;
                font-size: 14px;
            }
            
            .controls-info {
                display: none;
            }
            
            .mobile-controls {
                display: flex;
            }
            
            .joystick-area {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui-overlay">
        <div class="stats-panel">
            <h3>СТАТИСТИКА</h3>
            <div class="stat-row">
                <span>Очки:</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-row">
                <span>Скорость:</span>
                <span class="stat-value" id="speed">1.0x</span>
            </div>
            <div class="stat-row">
                <span>Игроков:</span>
                <span class="stat-value" id="players">1</span>
            </div>
            <div class="stat-row">
                <span>Пули/сек:</span>
                <span class="stat-value" id="fire-rate">2</span>
            </div>
            <div class="stat-row">
                <span>Урон пули:</span>
                <span class="stat-value" id="bullet-damage">1</span>
            </div>
        </div>
        
        <div class="cards-panel">
            <h3>БЛИЖАЙШИЕ КАРТОЧКИ</h3>
            <div id="cards-list"></div>
        </div>
        
        <div class="controls-info">
            <h4>УПРАВЛЕНИЕ</h4>
            <p>PC: WASD/Стрелки - движение</p>
            <p>Мышь - выбор цели</p>
            <p>Телефон: Смахивание/Джойстик</p>
            <p>Касание карточки - выбор</p>
            <p>Авто-стрельба по ближайшей цели</p>
        </div>
        
        <div class="mobile-controls">
            <div class="mobile-btn" id="btn-left">←</div>
            <div class="mobile-btn" id="btn-right">→</div>
            <div class="mobile-btn" id="btn-up">↑</div>
            <div class="mobile-btn" id="btn-down">↓</div>
        </div>
        
        <div class="joystick-area">
            <div class="joystick" id="joystick"></div>
        </div>
    </div>
    
    <div class="game-over" id="game-over">
        <h1>ИГРА ОКОНЧЕНА</h1>
        <p>Ваш счет: <span id="final-score">0</span></p>
        <p>Собрано карточек: <span id="cards-collected">0</span></p>
        <button class="restart-btn" id="restart-btn">ИГРАТЬ СНОВА</button>
    </div>
    
    <div class="ability-notification" id="ability-notification">
        Получена новая способность!
    </div>

    <script>
        // Основные константы игры
        const GAME_CONFIG = {
            playerSpeed: 0.1,
            bulletSpeed: 0.3,
            fireRate: 500, // мс между выстрелами
            laneCount: 3,
            laneWidth: 4,
            cardSpawnDistance: 30,
            maxCardsPerLane: 2,
            initialHealth: 100,
            cardValues: {
                negative: [-50, -40, -30, -25, -20, -15, -10, -5],
                positive: [10, 15, 20, 25, 30, 40, 50] // Хотя ты просил только отрицательные, оставлю на случай балансировки
            }
        };

        // Игровое состояние
        const gameState = {
            score: 0,
            health: GAME_CONFIG.initialHealth,
            players: 1,
            fireRateMultiplier: 1,
            bulletDamage: 1,
            speedMultiplier: 1,
            cardsCollected: 0,
            gameOver: false,
            abilities: {
                doubleBullets: false,
                spreadShot: false,
                rapidFire: false,
                extraPlayers: 0
            }
        };

        // Три основные полосы (дорожки)
        const lanes = [];
        let scene, camera, renderer, controls;
        let player, bullets = [];
        let cards = [];
        let otherPlayers = [];
        
        // Элементы UI
        const scoreElement = document.getElementById('score');
        const speedElement = document.getElementById('speed');
        const playersElement = document.getElementById('players');
        const fireRateElement = document.getElementById('fire-rate');
        const bulletDamageElement = document.getElementById('bullet-damage');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const cardsCollectedElement = document.getElementById('cards-collected');
        const restartBtn = document.getElementById('restart-btn');
        const abilityNotification = document.getElementById('ability-notification');
        const cardsListElement = document.getElementById('cards-list');
        
        // Управление
        const keys = {};
        let touchStartX = 0;
        let touchStartY = 0;
        let joystickActive = false;
        let joystickDirection = { x: 0, y: 0 };
        let targetLane = 1; // Центральная полоса (0, 1, 2)

        // Инициализация игры
        function init() {
            // Создание сцены
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);
            
            // Добавление тумана для глубины
            scene.fog = new THREE.Fog(0x111122, 10, 100);
            
            // Создание камеры
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 20);
            camera.lookAt(0, 0, 0);
            
            // Создание рендерера
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Добавление освещения
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Создание полос
            createLanes();
            
            // Создание игрока
            createPlayer();
            
            // Создание других игроков (пока неактивны)
            createOtherPlayers();
            
            // Создание начальных карточек
            spawnInitialCards();
            
            // Настройка элементов управления
            setupControls();
            
            // Начало игрового цикла
            gameLoop();
            
            // Авто-спавн карточек
            setInterval(spawnCards, 3000);
            
            // Авто-стрельба
            setInterval(autoShoot, GAME_CONFIG.fireRate / gameState.fireRateMultiplier);
        }
        
        // Создание полос (дорожек)
        function createLanes() {
            const laneGeometry = new THREE.PlaneGeometry(GAME_CONFIG.laneWidth, 1000);
            const laneMaterials = [
                new THREE.MeshPhongMaterial({ color: 0x333333, side: THREE.DoubleSide }), // Левая
                new THREE.MeshPhongMaterial({ color: 0x444444, side: THREE.DoubleSide }), // Центральная
                new THREE.MeshPhongMaterial({ color: 0x333333, side: THREE.DoubleSide })  // Правая
            ];
            
            for (let i = 0; i < GAME_CONFIG.laneCount; i++) {
                const lane = new THREE.Mesh(laneGeometry, laneMaterials[i]);
                lane.rotation.x = -Math.PI / 2;
                lane.position.x = (i - 1) * GAME_CONFIG.laneWidth;
                lane.position.y = -0.5;
                lane.receiveShadow = true;
                scene.add(lane);
                lanes.push(lane);
                
                // Добавление границ полос
                const borderGeometry = new THREE.BoxGeometry(0.2, 1, 1000);
                const borderMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                
                const leftBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                leftBorder.position.x = (i - 1) * GAME_CONFIG.laneWidth - GAME_CONFIG.laneWidth / 2 - 0.1;
                leftBorder.position.y = 0;
                scene.add(leftBorder);
                
                const rightBorder = new THREE.Mesh(borderGeometry, borderMaterial);
                rightBorder.position.x = (i - 1) * GAME_CONFIG.laneWidth + GAME_CONFIG.laneWidth / 2 + 0.1;
                rightBorder.position.y = 0;
                scene.add(rightBorder);
            }
        }
        
        // Создание игрока
        function createPlayer() {
            const group = new THREE.Group();
            
            // Тело игрока
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff88 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            group.add(body);
            
            // Голова
            const headGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffaa88 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            group.add(head);
            
            // Оружие (пистолет)
            const gunGroup = new THREE.Group();
            const gunBodyGeometry = new THREE.BoxGeometry(0.8, 0.2, 0.2);
            const gunBodyMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const gunBody = new THREE.Mesh(gunBodyGeometry, gunBodyMaterial);
            gunBody.position.x = 0.5;
            gunGroup.add(gunBody);
            
            const gunBarrelGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
            const gunBarrel = new THREE.Mesh(gunBarrelGeometry, gunBodyMaterial);
            gunBarrel.position.x = 0.9;
            gunBarrel.rotation.z = Math.PI / 2;
            gunGroup.add(gunBarrel);
            
            gunGroup.position.set(0, 0.8, 0);
            group.add(gunGroup);
            
            group.position.z = -10;
            scene.add(group);
            player = group;
        }
        
        // Создание других игроков
        function createOtherPlayers() {
            for (let i = 0; i < 2; i++) { // Максимум 2 дополнительных игрока
                const group = new THREE.Group();
                
                const bodyGeometry = new THREE.CylinderGeometry(0.25, 0.25, 1, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: i === 0 ? 0x0088ff : 0xff8800 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                group.add(body);
                
                const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffaa88 });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.2;
                group.add(head);
                
                group.visible = false;
                scene.add(group);
                otherPlayers.push(group);
            }
        }
        
        // Обновление других игроков
        function updateOtherPlayers() {
            const activePlayers = Math.min(gameState.players - 1, otherPlayers.length);
            
            for (let i = 0; i < otherPlayers.length; i++) {
                if (i < activePlayers) {
                    otherPlayers[i].visible = true;
                    // Позиционирование других игроков вокруг основного
                    const angle = (i + 1) * Math.PI / 3;
                    otherPlayers[i].position.x = player.position.x + Math.cos(angle) * 2;
                    otherPlayers[i].position.z = player.position.z + Math.sin(angle) * 2;
                    otherPlayers[i].position.y = 0;
                } else {
                    otherPlayers[i].visible = false;
                }
            }
        }
        
        // Создание карточки
        function createCard(laneIndex, zPosition) {
            const isNegative = Math.random() > 0.3; // 70% отрицательных карточек
            const value = isNegative ? 
                GAME_CONFIG.cardValues.negative[Math.floor(Math.random() * GAME_CONFIG.cardValues.negative.length)] :
                GAME_CONFIG.cardValues.positive[Math.floor(Math.random() * GAME_CONFIG.cardValues.positive.length)];
            
            const group = new THREE.Group();
            
            // Основа карточки
            const cardGeometry = new THREE.BoxGeometry(1.5, 0.1, 2);
            const cardMaterial = new THREE.MeshPhongMaterial({ 
                color: isNegative ? 0xff5555 : 0x0088ff,
                emissive: isNegative ? 0x440000 : 0x001144,
                emissiveIntensity: 0.3
            });
            const card = new THREE.Mesh(cardGeometry, cardMaterial);
            card.castShadow = true;
            group.add(card);
            
            // Текст значения
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = isNegative ? '#ff5555' : '#0088ff';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'white';
            context.font = 'bold 60px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(value > 0 ? `+${value}` : value.toString(), canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const textGeometry = new THREE.PlaneGeometry(1, 0.5);
            const textMaterial = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const text = new THREE.Mesh(textGeometry, textMaterial);
            text.position.z = 0.06;
            text.rotation.x = Math.PI / 2;
            group.add(text);
            
            // Позиционирование
            group.position.x = (laneIndex - 1) * GAME_CONFIG.laneWidth;
            group.position.y = 0.5;
            group.position.z = zPosition;
            group.rotation.x = -Math.PI / 2;
            
            // Сохранение данных карточки
            group.userData = {
                type: 'card',
                value: value,
                lane: laneIndex,
                isNegative: isNegative,
                health: Math.abs(value) // Карточка имеет "здоровье" равное её значению
            };
            
            scene.add(group);
            cards.push(group);
            
            updateCardsUI();
        }
        
        // Спавн начальных карточек
        function spawnInitialCards() {
            for (let lane = 0; lane < GAME_CONFIG.laneCount; lane++) {
                for (let i = 0; i < 2; i++) {
                    createCard(lane, i * 10 + 20);
                }
            }
        }
        
        // Спавн новых карточек
        function spawnCards() {
            if (gameState.gameOver) return;
            
            // Удаление карточек, которые далеко позади
            cards = cards.filter(card => {
                if (card.position.z < player.position.z - 20) {
                    scene.remove(card);
                    return false;
                }
                return true;
            });
            
            // Проверка количества карточек на каждой полосе
            const cardsPerLane = [0, 0, 0];
            cards.forEach(card => {
                cardsPerLane[card.userData.lane]++;
            });
            
            // Спавн новых карточек на пустых полосах
            for (let lane = 0; lane < GAME_CONFIG.laneCount; lane++) {
                if (cardsPerLane[lane] < GAME_CONFIG.maxCardsPerLane) {
                    const zPosition = player.position.z + GAME_CONFIG.cardSpawnDistance + Math.random() * 20;
                    createCard(lane, zPosition);
                }
            }
        }
        
        // Автоматическая стрельба
        function autoShoot() {
            if (gameState.gameOver) return;
            
            // Поиск ближайшей карточки на текущей полосе
            let nearestCard = null;
            let minDistance = Infinity;
            
            cards.forEach(card => {
                if (card.userData.lane === targetLane) {
                    const distance = card.position.z - player.position.z;
                    if (distance > 0 && distance < minDistance && distance < 30) {
                        minDistance = distance;
                        nearestCard = card;
                    }
                }
            });
            
            if (nearestCard) {
                shootAtCard(nearestCard);
                
                // Если есть способность разброса, стреляем и по соседним карточкам
                if (gameState.abilities.spreadShot) {
                    cards.forEach(card => {
                        if (card !== nearestCard && 
                            Math.abs(card.position.z - nearestCard.position.z) < 5 &&
                            Math.abs(card.userData.lane - nearestCard.userData.lane) <= 1) {
                            setTimeout(() => shootAtCard(card), 100);
                        }
                    });
                }
            }
        }
        
        // Выстрел по карточке
        function shootAtCard(card) {
            // Создание пули
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.5
            });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Позиция выстрела (из оружия игрока)
            bullet.position.copy(player.position);
            bullet.position.y += 0.8;
            bullet.position.x += 0.5;
            
            // Направление к карточке
            const direction = new THREE.Vector3(
                card.position.x - bullet.position.x,
                card.position.y - bullet.position.y,
                card.position.z - bullet.position.z
            ).normalize();
            
            bullet.userData = {
                direction: direction,
                speed: GAME_CONFIG.bulletSpeed * gameState.speedMultiplier,
                damage: gameState.bulletDamage,
                target: card
            };
            
            scene.add(bullet);
            bullets.push(bullet);
            
            // Если есть способность двойных пуль, создаем вторую пулю
            if (gameState.abilities.doubleBullets) {
                setTimeout(() => {
                    const bullet2 = new THREE.Mesh(bulletGeometry, bulletMaterial);
                    bullet2.position.copy(player.position);
                    bullet2.position.y += 0.8;
                    bullet2.position.x += 0.5;
                    
                    // Немного другое направление для разнообразия
                    const direction2 = direction.clone();
                    direction2.x += (Math.random() - 0.5) * 0.2;
                    direction2.z += (Math.random() - 0.5) * 0.2;
                    direction2.normalize();
                    
                    bullet2.userData = {
                        direction: direction2,
                        speed: GAME_CONFIG.bulletSpeed * gameState.speedMultiplier,
                        damage: gameState.bulletDamage,
                        target: card
                    };
                    
                    scene.add(bullet2);
                    bullets.push(bullet2);
                }, 50);
            }
        }
        
        // Обновление пуль
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Движение пули
                bullet.position.x += bullet.userData.direction.x * bullet.userData.speed;
                bullet.position.y += bullet.userData.direction.y * bullet.userData.speed;
                bullet.position.z += bullet.userData.direction.z * bullet.userData.speed;
                
                // Проверка столкновения с карточкой
                const target = bullet.userData.target;
                if (target && bullet.position.distanceTo(target.position) < 2) {
                    // Нанесение урона карточке
                    target.userData.health -= bullet.userData.damage;
                    
                    // Удаление пули
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    
                    // Если здоровье карточки <= 0, она уничтожена
                    if (target.userData.health <= 0) {
                        collectCard(target);
                        cards.splice(cards.indexOf(target), 1);
                        scene.remove(target);
                    }
                    
                    continue;
                }
                
                // Удаление пуль, которые улетели слишком далеко
                if (bullet.position.z > player.position.z + 50 || 
                    bullet.position.y < -10) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        // Сбор карточки
        function collectCard(card) {
            gameState.cardsCollected++;
            
            if (card.userData.isNegative) {
                // Отрицательная карточка - наносит урон
                gameState.health += card.userData.value; // value отрицательное
                
                if (gameState.health <= 0) {
                    gameOver();
                    return;
                }
            } else {
                // Положительная карточка - дает способность
                gameState.score += Math.abs(card.userData.value);
                
                // Случайная способность
                const abilities = ['doubleBullets', 'spreadShot', 'rapidFire', 'extraPlayers'];
                const randomAbility = abilities[Math.floor(Math.random() * abilities.length)];
                
                if (randomAbility === 'extraPlayers') {
                    gameState.players = Math.min(gameState.players + 1, 3);
                    gameState.abilities.extraPlayers = gameState.players - 1;
                    showAbilityNotification('Дополнительный игрок!');
                } else if (randomAbility === 'doubleBullets') {
                    gameState.abilities.doubleBullets = true;
                    showAbilityNotification('Двойные пули!');
                } else if (randomAbility === 'spreadShot') {
                    gameState.abilities.spreadShot = true;
                    showAbilityNotification('Разброс пуль!');
                } else if (randomAbility === 'rapidFire') {
                    gameState.fireRateMultiplier *= 1.5;
                    showAbilityNotification('Скорострельность увеличена!');
                }
                
                // Увеличение скорости с каждой положительной карточкой
                gameState.speedMultiplier *= 1.05;
            }
            
            updateUI();
            updateOtherPlayers();
        }
        
        // Показать уведомление о способности
        function showAbilityNotification(text) {
            abilityNotification.textContent = text;
            abilityNotification.style.display = 'block';
            
            setTimeout(() => {
                abilityNotification.style.display = 'none';
            }, 2000);
        }
        
        // Обновление UI
        function updateUI() {
            scoreElement.textContent = gameState.score;
            speedElement.textContent = gameState.speedMultiplier.toFixed(1) + 'x';
            playersElement.textContent = gameState.players;
            fireRateElement.textContent = Math.floor(1000 / (GAME_CONFIG.fireRate / gameState.fireRateMultiplier));
            bulletDamageElement.textContent = gameState.bulletDamage;
        }
        
        // Обновление списка карточек в UI
        function updateCardsUI() {
            cardsListElement.innerHTML = '';
            
            // Сортировка карточек по расстоянию
            const sortedCards = [...cards].sort((a, b) => {
                return a.position.z - b.position.z;
            });
            
            // Показываем только ближайшие 3 карточки
            const nearestCards = sortedCards.slice(0, 3);
            
            nearestCards.forEach(card => {
                const distance = Math.floor(card.position.z - player.position.z);
                const cardElement = document.createElement('div');
                cardElement.className = `card-info ${card.userData.isNegative ? 'card-negative' : 'card-positive'}`;
                cardElement.textContent = `${card.userData.value} (${distance}м)`;
                cardsListElement.appendChild(cardElement);
            });
        }
        
        // Конец игры
        function gameOver() {
            gameState.gameOver = true;
            finalScoreElement.textContent = gameState.score;
            cardsCollectedElement.textContent = gameState.cardsCollected;
            gameOverScreen.style.display = 'flex';
        }
        
        // Игровой цикл
        function gameLoop() {
            if (!gameState.gameOver) {
                // Движение игрока вперед
                player.position.z += GAME_CONFIG.playerSpeed * gameState.speedMultiplier;
                
                // Плавное перемещение между полосами
                const targetX = (targetLane - 1) * GAME_CONFIG.laneWidth;
                player.position.x += (targetX - player.position.x) * 0.1;
                
                // Обновление камеры (следует за игроком)
                camera.position.z = player.position.z + 20;
                camera.position.x = player.position.x;
                camera.lookAt(player.position.x, player.position.y + 5, player.position.z);
                
                // Обновление пуль
                updateBullets();
                
                // Обновление UI карточек
                updateCardsUI();
                
                // Проверка столкновения с карточками
                checkCardCollisions();
            }
            
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }
        
        // Проверка столкновений с карточками
        function checkCardCollisions() {
            for (let i = cards.length - 1; i >= 0; i--) {
                const card = cards[i];
                const distance = player.position.distanceTo(card.position);
                
                // Если игрок коснулся карточки
                if (distance < 2) {
                    collectCard(card);
                    cards.splice(i, 1);
                    scene.remove(card);
                }
            }
        }
        
        // Настройка управления
        function setupControls() {
            // Клавиатура
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                if (e.key === 'ArrowLeft' || e.key === 'a') {
                    targetLane = Math.max(0, targetLane - 1);
                } else if (e.key === 'ArrowRight' || e.key === 'd') {
                    targetLane = Math.min(GAME_CONFIG.laneCount - 1, targetLane + 1);
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            // Сенсорное управление
            const joystick = document.getElementById('joystick');
            const joystickArea = document.querySelector('.joystick-area');
            
            joystickArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            
            joystickArea.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!joystickActive) return;
                
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                
                const deltaX = touchX - touchStartX;
                const deltaY = touchY - touchStartY;
                
                // Ограничение движения джойстика
                const maxDistance = 40;
                const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), maxDistance);
                const angle = Math.atan2(deltaY, deltaX);
                
                joystick.style.left = `${30 + Math.cos(angle) * distance}px`;
                joystick.style.top = `${30 + Math.sin(angle) * distance}px`;
                
                // Определение направления
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    if (deltaX > 20 && targetLane < GAME_CONFIG.laneCount - 1) {
                        targetLane++;
                        touchStartX = touchX; // Сброс для следующего движения
                    } else if (deltaX < -20 && targetLane > 0) {
                        targetLane--;
                        touchStartX = touchX;
                    }
                }
            });
            
            joystickArea.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                joystick.style.left = '30px';
                joystick.style.top = '30px';
            });
            
            // Кнопки рестарта
            restartBtn.addEventListener('click', restartGame);
            
            // Адаптация к размеру окна
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Мобильные кнопки
            const mobileButtons = ['btn-left', 'btn-right', 'btn-up', 'btn-down'];
            mobileButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (btnId === 'btn-left') targetLane = Math.max(0, targetLane - 1);
                    if (btnId === 'btn-right') targetLane = Math.min(GAME_CONFIG.laneCount - 1, targetLane + 1);
                });
            });
        }
        
        // Перезапуск игры
        function restartGame() {
            // Сброс состояния
            gameState.score = 0;
            gameState.health = GAME_CONFIG.initialHealth;
            gameState.players = 1;
            gameState.fireRateMultiplier = 1;
            gameState.bulletDamage = 1;
            gameState.speedMultiplier = 1;
            gameState.cardsCollected = 0;
            gameState.gameOver = false;
            gameState.abilities = {
                doubleBullets: false,
                spreadShot: false,
                rapidFire: false,
                extraPlayers: 0
            };
            
            // Очистка сцены
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            
            // Очистка массивов
            bullets = [];
            cards = [];
            otherPlayers = [];
            
            // Скрытие экрана окончания игры
            gameOverScreen.style.display = 'none';
            
            // Переинициализация
            init();
        }
        
        // Запуск игры при загрузке
        window.addEventListener('load', init);
    </script>
</body>
</html>
